# 3-1 전역 공간에서의 this(브라우저 환경)
전역 공간에서 this는 전역 객체를 가리킴

개념상 전역 컨텍스트를 생성하는 주체가 전역 객체이기 때문

브라우저 환경에서는 window, Node.js 환경에서는 global

# 3-2 전역 공간에서의 this(node.js 환경)
VSCODE에서 돌려보면 this가 빈 객체

js 파일에서 작성하는 코드 전체는 하나의 함수 내부로 들어가게 되므로 당연히 비교 결과도 false로 나오는 결과

js파일은 하나의 함수 안에서 실행되므로, 해당 함수 내부에 존재하는 기본 객체가 this의 참조값이 됨

따라서 교재의 결과와 다르게 나옴


"다음 코드 참고"

console.log(this, module.exports, exports); // {}, {}, {} 

console.log(this === module.exports); // true 

console.log(this === exports); // true 

console.log(module.exports === exports); // true 

console.log(this === global); // false


실제 global이 전역 객체인 것을 확인하려면 어떤 함수든 일반 함수로 실행되면 해당 함수 내부에서 참조하는 this는 전역객체라는 점을 이용


"다음 코드 참고"

function a() { 

console.log(this) // global 
    
console.log(this === global) // true 
    
} 

a()

# 3-3 전역변수와 전역객체(1)
자바스크립트의 모든 변수는 특정 객체의 프로퍼티로서 동작

여기서 특정 객체란 실행 컨텍스트의 "LexicalEnvironment(L.E)"

실행 컨텍스트는 변수를 수집해서 L.E의 프로퍼티로 저장

# 3-4 전역변수와 전역객체(2)
전역 변수를 선언하면 자바스크립트 엔진은 이를 전역 객체의 프로퍼티로 할당

전역 공간에서는 var 변수를 선언하는 대신 window의 프로퍼티에 직접 할당하더라도 결과적으로 var로 선언한 것과 똑같이 동작할 것을 예상할 수 있음 (삭제 명령 제외)

# 3-5 전역변수와 전역객체(3)
전역 변수를 선언하면 자바스크립트 엔진이 자동으로 전역객체의 프로퍼티로 할당하면서 추가적으로 해당 프로퍼티의 configurable attribute(변경 및 삭제 가능성)을 false로 정의

# 3-6 함수로서 호출, 메서드로서 호출
함수와 메서드를 구분하는 유일한 차이점 : "독립성"

자바스크립트에서는 상황별로 this 키워드에 다른 값을 부여하게 함으로써 이를 구현한

# 3-7 메서드로서 호출 - 점 표기법, 대괄호 표기법
함수를 호출할 때 그 함수 이름 앞에 객체가 명시되어 있는 경우 : 메서드로 호출한 것

그렇지 않은 모든 경우 : 함수로 호출한 것

# 3-8 메서드 내부에서의 this
this에는 호출한 주체에 대한 정보가 담김

함수를 메서드로 호출한 경우 호출한 주체는 함수명 앞의 객체 => 이 객체가 곧 this

# 3-9 내부함수에서의 this
this가 가리키고 있는 것

(1): obj1, (2) 전역 객체(window), (3): obj2

# 3-10 내부함수에서의 this를 우회하는 방법
innerFunc1 내부에서 this는 전역 객체를 가리킴

한편 outer 스코프에서 self라는 변수에 this를 저장한 상태에서 호출한 innerFUnc2의 경우 self에는 객체 obj가 출력

이와 같은 방식으로 this를 상속한 것 처럼 활용

# 3-11 this를 바인딩하지 않는 함수(화살표 함수)
함수 내부에서 this가 전역객체를 바라보는 문제를 보완하고자 도입

화살표 함수는 실행 컨텍스트를 생성할 때 this 바인딩 과정 자체가 빠지게 되어, 상위 스코프의 this를 그대로 활용

# 3-12 콜백 함수 내부에서의 this
콜백 함수도 함수이기 때문에 기본적으로 this가 전역 객체를 참조

제어권을 받은 함수에서 콜백 함수에 별도로 this가 될 대상을 지정한 경우에는 그 대상을 참조

(1), (2)는 전역객체를 참조

(3)의 addEventListener 메서드는 콜백 함수를 호출할 때 자신의 this를 상속하도록 정의 (document.body.querySelector('#a')가 this)

# 3-13 생성자 함수
생성자 함수를 호출하면 생성자의 prototype 프로퍼티를 참조하는 __proto__ 라는 프로퍼티가 있는 객체를 만들고, 미리 준비된 공통 속성 및 개성을 해당 객체(this)에 부여

생성자 함수로서 호출된 경우 : 내부에서의 this는 새로 만들 구체적인 인스턴스 자신

# 3-14 call 메서드(1)
this에 별도의 대상을 바인딩하는 방법

call 메서드는 메서드의 호출 주체인 함수를 즉시 실행하도록 하는 명령어 메서드의 첫번째 인자를 this로 바인딩, 이후의 인자들을 호출할 함수의 매개변수로 함

함수를 그냥 실행하면 this는 전역객체를 참조하지만, call 메서드 이용시 객체를 this로 지정

# 3-15 call 메서드(2)
메서드에 대해서도 마찬가지로 객체의 메서드를 그냥 호출하면 this는 객체를 참조하지만, call 메서드를 이용하면 임의의 객체를 this로 지정 가능

# 3-16 apply 메서드
apply 메서드는 call 메서드와 기능적으로 완전히 동일

apply 메서드는 두 번째 인자를 배열로 받아 그 배열의 요소들을 호출할 함수의 매개변수로 지정

# 3-17 call/apply 메서드의 활용 1-1) 유사배열객체에 배열 메서드를 적용
call/apply 메서드를 이용하여 객체에 배열 메서드를 적용한 예제

# 3-18 call/apply 메서드의 활용 1-2) arguments, NodeList에 배열 메서드 적용
유사배열객체에는 call/apply 메서드를 이용해 모든 배열 메서드 적용 가능

단, 문자열의 경우 length 프로퍼티가 읽기 전용이므로 원본 문자열에 변경을 가하는 메서드는 에러

concat도 대상이 반드시 배열이어야 하는 경우 에러가 나지 않더라도 원하는 결과를 얻을 수 없음

# 3-19 call/apply 메서드의 활용 1-3) 문자열에 배열 메서드 적용 예시
문자열의 경우 length 프로퍼티가 읽기 전용이므로 원본 문자열에 변경을 가하는 메서드는 에러

concat도 대상이 반드시 배열이어야 하는 경우 에러가 나지 않더라도 원하는 결과를 얻을 수 없음

# 3-20 call/apply 메서드의 활용 1-4) ES6의 Array.from 메서드
ES6에서  유사배열객체 또는 순회 가능한 모든 종류의 데이터 타입을 배열로 전환하는 Array.from 메서드를 도입함으로써, 예제 3-19와 같은 활용은 잘 사용하지 않음

# 3-21 call/apply 메서드의 활용 2) 생성자 내부에서 다른 생성자를 호출
생성자 내부에 다른 생성자와 공통된 내용이 있을 경우 call 또는 apply 를 이용하여 다른 생성자를 호출하면 간단하게 반복을 줄일 수 있음

# 3-22 call/apply 메서드의 활용 3-1) 최대/최솟값을 구하는 코드를 직접 구현
코드가 불필요하게 길고 가독성도 떨어짐

이후의 두 예제의 방법을 통해 개선

# 3-23 call/apply 메서드의 활용 3-2) 여러 인수를 받는 메세드(Math.max/Math.min)에 apply 적용
Math.max/Math.min메서드에 apply 를 적용하여 예제 3-22를 더 간단히 구현

# 3-24 call/apply 메서드의 활용 3-3) ES6의 펼치기 연산자 활용
ES6에서의 펼치기 연산자를 이용하여 예제 3-23보다 더 쉽게 구현

# 3-25 bind 메서드 - this 지정과 부분 적용 함수 구현
bind 메서드는 ES5에 추가된 기능

call과 비슷하지만 즉시 호출하지는 않고 넘겨받은 this 및 인수들을 바탕으로 새로운 함수를 반환하기만 하는 메서드

다시 새로운 함수를 호출할 때 인수를 넘기면 그 인수들은 기존 bind메서드를 호출할 때 전달했던 인수들의 뒤에 이어서 등록

즉, bind 메서드는 함수에 this를 미리 적용하는 것과 부분 적용 함수를 구현하는 두가지 목적을 모두 지님

# 3-26 bind 메서드 - name 프로퍼티
name 프로퍼티에 동사 bind의 수동태인 bound라는 접두어가 붙음

함수의 name 프로퍼티가 bound a라면 이는 곧 함수명이 a인 원본 함수에 bind 메서드를 적용했다는 의미

# 3-27 내부함수에 this 전달-call vs bind
3-1-3절에서 메서드의 내부함수에 메서드의 this를 그대로 바라보게 하기 위한 방법으로 self등의 변수를 활용한 우회법을 소개했음

call,apply 또는 bind 메서드를 이용하면 이를 더 깔끔하게 처리

# 3-28 bind 메서드-내부함수에 this 전달
콜백 함수를 인자로 받는 함수나 메서드 중에서 기본적으로 콜백 함수 내에서의 this에 관여하는 함수 또는 메서드에 대해서도 bind 메서드를 이용하면 this 값을 사용자에 맞게 바꿀 수 있음

# 3-29 화살표 함수 내부에서의 this
화살표 함수는 실행 컨텍스트 생성 시 this를 바인딩하는 과정 제외

이 함수 내부에는 this가 없으며, 접근하고자 하면 스코프 체인상 가장 가까운 this에 접근

# 3-30 thisArg를 받는 경우 예시-forEach 메서드
별도의 인자로 this를 받는 경우 (콜백 함수 내에서의 this)

콜백 함수를 인자로 받는 메서드 중 일부는 추가로 this로 지정할 객체(thisArg)를 인자로 지정할 수 있음

이러한 메서드의 thisArg 값을 지정하면 콜백 함수 내부에서 this 값을 원하는 대로 변경 가능

이런 형태는 여러 내부 요소에 대해 같은 동작을 반복 수행해야 하는 배열 메서드 많이 포진되어 있으며, 같은 이유로 ES6에서 새로 등장한 Set,Map 등의 메서드에도 일부 존재

# 3-31 콜백 함수와 함께 thisArg를 인자로 받는 메서드
예제 3-30은 forEach를 예로 들었지만, 이 밖에도 thisArg를 인자로 받는 많은 메서드들이 존재
