# Ch.7 예제 정리

## 7-1 스태틱 메서드, 프로토타입 메서드  
생성자 함수에서 정의한 메서드 중 인스턴스에서 직접 호출 가능한 건 프로토타입 메서드임.  
생성자 함수 자체에 붙어 있는 메서드는 스태틱 메서드로, 인스턴스에서는 직접 호출 불가함.

---

## 7-2 6-2-4절의 Grade 생성자 함수 및 인스턴스  
Grade 생성자는 배열처럼 작동하게끔 설계됨.  
프로토타입을 배열로 지정해서 배열 메서드를 사용할 수 있게 했지만,  
구체 데이터를 포함하고 있어 완전히 추상적인 클래스 구조라고 보기 어려움.  
특히 `length`가 configurable이라는 점과 `prototype`이 배열인 점은 문제 소지가 있음.

---

## 7-3 length 프로퍼티를 삭제한 경우  
Grade 인스턴스는 일반 객체이기 때문에 `length` 프로퍼티를 삭제할 수 있음.  
이후 `push` 같은 배열 메서드를 사용할 경우 예상치 못한 방식으로 작동하게 됨.  
배열처럼 보이지만 배열과 다르게 동작하는 특성이 있음.

---

## 7-4 요소가 있는 배열을 prototype에 매칭한 경우  
프로토타입 자체에 값이 들어가 있으면 인스턴스 동작에 영향을 줄 수 있음.  
이는 클래스의 추상성을 해치는 설계 방식임.  
프로토타입은 메서드만 포함하고 구체적인 데이터를 가지면 안 됨.

---

## 7-5 Recctangle.Square 클래스  
Rectangle과 Square 클래스는 구조가 유사하며,  
공통적으로 `width`를 가지며 `getArea` 메서드의 로직도 유사함.  
Square 클래스의 구조를 조금만 수정하면 Rectangle을 상속받을 수 있는 형태로 만들 수 있음.

---

## 7-6 Square 클래스 변형  
Square 클래스에서 `height`를 `width`와 같은 값으로 설정하면  
Rectangle의 `getArea` 메서드를 그대로 사용할 수 있게 됨.  
결과적으로 Rectangle을 상속받는 구조로 확장 가능해짐.

---

## 7-7 Rectangle을 상속하는 Square 클래스  
Square 생성자 함수 내부에서 Rectangle 생성자를 호출하고  
Rectangle 인스턴스를 프로토타입으로 연결함.  
하지만 여전히 구체 데이터가 들어가 있는 구조이며,  
추상화 측면에서는 부족한 점이 있음.

---

## 7-8 클래스 상속 및 추상화 방법(1) - 인스턴스 생성 후 프로퍼티 제거  
상속을 위해 SuperClass 인스턴스를 SubClass의 프로토타입으로 삼은 뒤,  
불필요한 프로퍼티를 모두 제거하고, `Object.freeze`로 변경을 방지함.  
이 방식은 추상성을 확보하는 간단한 방법임.

---

## 7-9 클래스 상속 및 추상화 방법(2) - 빈 함수를 활용  
Bridge라는 빈 함수를 중간에 두어 prototype 체인을 연결함.  
SuperClass의 인스턴스를 직접 상속하지 않기 때문에 구체 데이터 없이 연결 가능함.  
즉시 실행 함수로 메모리 사용도 최적화함.

---

## 7-10 클래스 상속 및 추상화 방법(3) - Object.create 활용  
`Object.create`를 활용하여 SubClass의 prototype을 설정함.  
SuperClass의 인스턴스를 직접 상속하지 않기 때문에  
더 안전하고 간결하게 상속 구조를 구성할 수 있음.  
ES5 이후 권장되는 방식임.

---

## 7-11 클래스 상속 및 추상화 방법 - 완성본(1) - 인스턴스 생성 후 프로퍼티 제거  
기존 extendClass1 방식에서 constructor가 SuperClass를 참조하던 문제를 수정하여  
SubClass의 prototype이 올바르게 자기 constructor를 가리키도록 개선함.

---

## 7-12 클래스 상속 및 추상화 방법 - 완성본(2) - 빈 함수를 활용  
Bridge 방식 상속 구조에 constructor 재설정을 추가하여  
prototype.constructor가 정확하게 SubClass를 참조하도록 개선함.

---

## 7-13 클래스 상속 및 추상화 방법 - 완성본(3) - Object.create 활용  
`Object.create` 방식에서도 prototype.constructor를 명확히 설정하여  
prototype 상속 구조를 완성도 있게 구성함.

---

## 7-14 상위 클래스 접근 수단인 super 메서드 추가  
super 메서드를 구현하여 하위 클래스에서 상위 클래스의 생성자 또는 메서드에 접근할 수 있도록 함.  
ES6의 `super` 키워드를 흉내낸 구현이며, 하위 클래스에서 상속된 메서드를 확장하거나 오버라이드할 때 유용함.

---

## 7-15 ES5와 ES6의 클래스 문법 비교  
ES5에서는 생성자 함수와 prototype을 이용해 클래스 구조를 구성했으며,  
정적 메서드와 인스턴스 메서드를 명확히 나누기 어려웠음.  
ES6에서는 class 문법이 도입되어 문법적 구조가 훨씬 명확하고 직관적임.

---

## 7-16 ES6의 클래스 상속  
ES6에서는 `extends` 키워드와 `super()`를 사용하여  
명시적으로 상속 관계를 구성할 수 있음.  
이전 예제에서 직접 구현한 `super`와 비교했을 때,  
구조적 안정성과 간결함 면에서 큰 차이를 보임.

---
