# 2-1 실행 컨텍스트랑 콜 스택
declaration => var a, function outer(), inner()

expression => a=1, console.log(a)

(declaration이 아닌 것들을 전부 expression이라 봐도 무방)

(1) 전역 컨텍스트가 콜 스택에 담김

(3) outer 함수를 호출하면 자바스크립트 엔진은 outer에 대한 환경 정보를 수집하여 실행 컨텍스트를 생성한 후 콜 스택에 담김

(2) 에서 inner 함수의 실행 컨텍스트가 콜 스택 가장 위에 담김

순차적으로 실행

# 2-2 매개변수와 변수에 대한 호이스팅(1) - 원본 코드
1, undefined, 2 가 아닌 1,1,2 가 출력

인자를 함수 내부의 다른 코드보다 먼저 선언 및 할당이 이뤄진 것처럼 간주 (호이스팅)

위 예제는 2-3과 동일하게 작동

# 2-3 매개변수와 변수에 대한 호이스팅(2) - 매개변수를 변수 선언/할당과 같다고 간주해서 변환한 상태
호이스팅할 때 변수명만 끌어오고 할당 과정은 원래 자리에 그대로 남겨둠

매개변수의 경우도 마찬가지

수집 대상 1,2,3을 순서대로 끌어올리면 예제 2-4와 같은 형태로 바뀜

# 2-4 매개변수와 변수에 대한 호이스팅 (3) - 호이스팅을 마친 상태
environment record는 현재 실행될 컨텍스트의 대상 코드 내 어떤 식별자들이 있는지만 관심 있음

예제 2-2, 2-3, 2-4 는 environment record 입장에서 다르지 않음

실행 결과도 2-2, 2-3, 2-4와 동일

# 2-5 함수 선언의 호이스팅(1) - 원본 코드
a 함수 실행 순간, a 함수의 실행 컨텍스트가 생성

이때, 변수명과 함수 선언의 정보를 위로 끌어올림

변수는 선언부만 끌어올리지만 함수 선언은 함수 전체를 끌어올림

# 2-6 함수 선언의 호이스팅(2)-호이스팅을 마친 상태
예제 2-5와 동일하게 작동

이 예제는 예제 2-5의 호이스팅을 마친 상태를 코드로 표현한 것

# 2-7 함수 선언의 호이스팅(3)-함수 선언문을 함수 표현식으로 바꾼 코드
예제 2-5, 2-6에서의 코드와 동일하게 작동

해석의 편의를 위해 함수 선언문을 함수 표현식으로 바꾼 예제

# 2-8 함수를 정의하는 세가지 방식
함수를 정의하는 방법에 대해 알려주는 예제

기명 함수 표현식 사용시 주의할 점은 외부에서 함수명으로 함수를 호출할 수 없다는 것 (함수명은 함수 내부에서만 접근 가능)

# 2-9 함수 선언문과 함수 표현식(1)-원본 코드
console.log 함수에서 사용되는 multiply는 아직 할당이 되지 않았기 때문에 not a function라는 TypeError가 발생

함수 선언문은 전체를 호이스팅하고 함수 표현식은 변수 선언부만 호이스팅 했기 때문에 생긴 문제

# 2-10 함수 선언문과 함수 표현식(2)-호이스팅을 마친 상태
예제 2-9와 동일하게 작동

호이스팅을 마친 상태를 코드로 표현한 것

# 2-11 함수 선언문의 위험성
전역 컨텍스트가 활성화 될 때 전역공간에 선언된 함수들이 모두 가장 위로 끌어올려짐

동일한 변수명에 서로 다른 값을 할당할 경우 나중에 할당한 값이 먼저 할당한 값을 덮어씌움

따라서, 위와 같은 예제에서 마지막 함수만 동작

에러가 발생하지 않아 디버깅에 어려움이 발생

# 2-12 상대적으로 함수 표현식이 안전
함수 표현식을 사용하면 예제 2-11과 같은 문제를 예방할 수 있음

# 2-13 스코프 체인
스코프 : 식별자에 대한 유효범위

무조건 스코프체인 상에서 가장 먼저 발견된 식별자에만 접근 가능

# 2-14 스코프 체인 확인(1) - 크롬 전용
함수 내부에서 실제로 호출할 외부 변수들의 정보만 보여줌

# 2-15 스코프 체인 확인(2) - 크롬 전용
함수 내부에서 실제로 호출할 외부 변수들의 정보만 보여줌

# 2-16 스코프 체인 확인(3)
디버거를 이용하면 좀 더 제대로 된 정보 확인 가능
