# Ch.6 프로토타입과 prototype 체이닝

## 6-1 Person.prototype

함수의 `prototype`에 메서드나 프로퍼티가 있으면, 인스턴스도 마치 자신의 것처럼 해당 메서드나 프로퍼티에 접근 가능함.
단, `__proto__`를 통해 직접 접근하면 예기치 못한 결과가 나올 수 있음.

---

## 6-2 prototype과 __proto__

함수의 `prototype`에 정의된 속성들은 생성된 인스턴스에서도 접근 가능함.
크롬 개발자도구의 `console.dir()`을 활용하면 함수 객체와 인스턴스 객체의 구조와 `__proto__` → `prototype` 연결 관계를 시각적으로 확인 가능함.

---

## 6-3 constructor 프로퍼티

생성자 함수의 `prototype` 객체 내부에는 `constructor`라는 프로퍼티가 있음.
이 프로퍼티는 원래 자신을 생성한 생성자 함수를 참조함.
이 덕분에 `인스턴스 → __proto__ → constructor`를 통해 생성자 함수에 접근 가능함.

---

## 6-4 constructor 변경

일반 객체나 배열 등의 `constructor`는 직접 변경 가능함.
그러나 이는 단지 `constructor` 프로퍼티만 바꾼 것이며, 실제 인스턴스의 내부 구조나 원형 객체는 그대로 유지됨.
따라서 `constructor`에 의존해서 타입을 판별하는 건 항상 안전하진 않음.

---

## 6-5 다양한 constructor 접근 방법

`new 생성자()` 외에도 `인스턴스.__proto__.constructor()` 또는 `Object.getPrototypeOf(인스턴스).constructor()` 등을 통해 constructor를 활용한 객체 생성 가능.
다양한 경로로 동일한 결과에 도달할 수 있음.

---

## 6-6 메서드 오버라이드

인스턴스가 동일한 이름의 메서드를 가지면, prototype에 정의된 메서드를 덮어쓰게 됨.
이를 메서드 오버라이드라 함.
인스턴스 자체에 정의된 메서드가 우선적으로 호출됨.

---

## 6-7 배열에서 배열 메서드 및 객체 메서드 실행

배열 객체에서 배열 고유의 메서드(`push`) 뿐 아니라 상위 객체인 `Object`의 메서드(`hasOwnProperty`)까지 사용 가능함.
이는 프로토타입 체이닝 덕분이며, 배열 → Array.prototype → Object.prototype 순으로 연결됨.

---

## 6-8 메서드 오버라이드와 프로토타입 체이닝

`toString()` 메서드처럼 prototype에 정의된 기본 메서드는 인스턴스에서 오버라이드 가능함.
메서드를 오버라이드하면 프로토타입 체인을 거치지 않고 인스턴스가 정의한 메서드가 우선 실행됨.

---

## 6-9 Object.prototype에 추가한 메서드 접근

`Object.prototype`에 메서드를 추가하면 모든 객체에서 접근 가능함.
그러나 숫자, 불리언, 함수 등 비객체 타입에 대해서는 기대한 방식으로 작동하지 않을 수 있음.
프로토타입 체인의 최상단은 항상 `Object.prototype`임.

---

## 6-10 Grade 생성자 함수와 인스턴스

배열처럼 동작하는 사용자 정의 객체를 만들기 위해 `arguments`를 활용하여 인스턴스의 프로퍼티와 `length`를 수동으로 정의할 수 있음.
상위 객체와 연결하고 싶다면, `__proto__`가 가리키는 대상을 명시적으로 설정해야 함.

---
