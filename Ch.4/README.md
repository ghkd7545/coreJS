# 4-1 콜백 함수 예제 (1-1) setInterval
콜백 함수는 다른 함수에 인자로 넘기는 함수임.
setInterval은 일정 시간마다 콜백을 반복 실행함.
ID 값을 반환하고, clearInterval로 중단 가능.
브라우저에선 window 생략 가능함.

# 4-2 콜백 함수 예제 (1-2) setInterval
콜백을 따로 정의하고 전달함.
직접 호출하면 사용자 제어, setInterval이 호출하면 제어권 setInterval에 있음.

# 4-3 콜백 함수 예제 (2-1) Array.prototype.map
배열의 각 요소에 콜백을 실행하고 결과를 새 배열로 반환함.
map은 콜백에 요소, 인덱스, 배열 순서로 인자를 넘김.

# 4-4 콜백 함수 예제 (2-2) Array.prototype.map - 인자 순서를 임의로 바꾸어 사용한 경우
map이 넘겨주는 인자 순서를 바꾸면 의도대로 동작 안 함.
콜백 호출 시 인자 제어권은 map이 가짐.

# 4-5 콜백 함수 예제 (2-3) Array.prototype.map - 구현
thisArg가 있으면 해당 값을 this로 바인딩, 없으면 window 사용함.
콜백에 요소, 인덱스, 배열을 순서대로 전달함.

# 4-6 콜백 함수 내부에서의 this
콜백이 어디서 어떻게 실행되느냐에 따라 this 값 달라짐.
setTimeout이나 forEach에선 window, 이벤트 핸들러에선 DOM 요소가 this가 됨.

# 4-7 메서드를 콜백 함수로 전달한 경우
객체의 메서드를 콜백으로 넘기면 일반 함수처럼 호출됨.
this가 객체가 아닌 window로 바뀜.

# 4-8 콜백 함수 내부의 this에 다른 값을 바인딩하는 방법(1) - 전통적인 방식
this를 self 같은 변수에 저장해서 클로저로 우회함.
직접적인 this 사용은 아니지만 재활용 가능.

# 4-9 콜백 함수 내부에서 this를 사용하지 않는 경우
객체를 직접 참조하면 코드 간결함.
다만 this가 아닌 객체명을 고정 참조하므로 유연성 떨어짐.

# 4-10 예제 4-8의 func 함수 재활용
전통적인 self 패턴을 사용해 다양한 객체에 재활용 가능함.
this를 직접 쓰진 않지만 유효하게 관리할 수 있음.

# 4-11 콜백 함수 내부의 this에 다른 값을 바인딩하는 방법(2) - bind 메서드 활용
bind로 this를 고정해 콜백 전달 시도에 대응함.
더 간결하고 확실하게 this 설정 가능.

# 4-12 콜백 지옥 예시(1-1)
콜백을 계속 중첩 호출하면 들여쓰기 깊어지고 가독성 저하됨.
이런 구조를 콜백 지옥이라 부름.

# 4-13 콜백 지옥 해결 - 기명함수로 변환
콜백을 함수로 분리해 중첩 구조 완화함.
가독성과 유지보수성 개선됨.

# 4-14 비동기 작업의 동기적 표현(1) - Promise(1)
Promise를 사용해 then 체인으로 비동기 흐름 제어 가능함.
콜백보다 읽기 쉬운 구조 제공.

# 4-15 비동기 작업의 동기적 표현(2) - Promise(2)
Promise 구조를 함수로 분리해 더 간결하게 표현함.
재사용성과 유연성 증가.

# 4-16 비동기 작업의 동기적 표현 (3) - Generator
yield를 이용해 실행 흐름을 중단/재개함.
next 호출로 순차적으로 제어 가능함.

# 4-17 비동기 작업의 동기적 표현(4) - Promise + Async/await
가장 가독성 좋고 작성이 쉬운 비동기 표현 방식.
Promise 기반으로 작동하며, 동기처럼 작성 가능함.
