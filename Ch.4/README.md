# Ch.4 예제 정리

## 4-1 콜백 함수 예제 (1-1) setInterval
setInterval은 지정된 시간 간격으로 콜백 함수를 반복 호출하는 비동기 함수임. 
콜백 함수가 특정 조건을 만족하면 clearInterval을 통해 반복을 중단할 수 있음. 
반복 제어를 위한 고유 ID가 반환되며, 이는 종료 시 필수로 사용됨.

## 4-2 콜백 함수 예제 (1-2) setInterval
콜백 함수를 변수로 분리하여 정의하고 이를 setInterval에 넘겨주는 방식. 
함수 호출 주체가 직접 호출하면 제어권은 사용자에게 있고, setInterval이 호출하면 제어권은 setInterval에게 있음. 
이를 통해 콜백 제어 구조 이해 가능.

## 4-3 콜백 함수 예제 (2-1) Array.prototype.map
Array.prototype.map은 배열의 각 요소를 순회하며 콜백을 실행하고, 결과를 모아 새로운 배열을 생성함. 
콜백은 세 개의 인자(currentValue, index, array)를 받고, 순서가 중요함.

## 4-4 콜백 함수 예제 (2-2) Array.prototype.map - 인자 순서를 임의로 바꾸어 사용한 경우
map에서 콜백 인자의 순서를 임의로 바꾸면 의도한 값이 전달되지 않아 결과가 이상하게 나옴. 
콜백 호출의 제어권은 map이 갖고 있으므로, 콜백 정의 시 정해진 순서를 지켜야 함.

## 4-5 콜백 함수 예제 (2-3) Array.prototype.map - 구현
map 메서드를 직접 구현한 예제로, 내부적으로 어떻게 콜백이 호출되고 어떤 인자가 전달되는지 알 수 있음. 
thisArg가 주어지면 해당 값을 this로, 없으면 window를 this로 바인딩하여 call 메서드로 실행함.

## 4-6 콜백 함수 내부에서의 this
콜백 함수 내부의 this는 호출 주체에 따라 값이 달라짐. 
setTimeout이나 forEach와 같은 일반 함수 호출에서는 window가 this가 되고, 이벤트 핸들러에서는 DOM 요소가 this가 됨. 
제어권에 따라 this 바인딩 방식이 달라짐.

## 4-7 메서드를 콜백 함수로 전달한 경우
객체의 메서드를 콜백 함수로 전달하면 this 바인딩이 끊어짐. 
해당 메서드는 일반 함수처럼 호출되기 때문에, this는 원래 객체가 아니라 전역 객체(window)를 가리키게 됨. 
메서드를 그대로 콜백으로 넘기는 경우 주의 필요.

## 4-8 콜백 함수 내부의 this에 다른 값을 바인딩하는 방법(1) - 전통적인 방식
전통적인 방식으로 콜백 내부에서 this를 유지하기 위해 self라는 변수에 this를 저장하고, 내부 함수에서 이를 참조하게 함. 
클로저를 활용해 this를 우회적으로 유지함.
다소 번거롭지만 재활용성 확보 가능.

## 4-9 콜백 함수 내부에서 this를 사용하지 않는 경우
this를 아예 사용하지 않고, 외부 객체를 직접 참조하는 방식. 
코드가 간결해지지만, 함수가 특정 객체에 종속되어 재사용성이 떨어짐. 
객체 이름이 바뀌면 내부 로직 수정 필요.

## 4-10 예제 4-8의 func 함수 재활용
self 방식으로 정의된 함수를 다른 객체에도 적용해 재사용하는 예제. 
클로저를 활용해 this 우회 바인딩이 가능하므로 객체마다 독립된 this 역할을 하도록 활용 가능.

## 4-11 콜백 함수 내부의 this에 다른 값을 바인딩하는 방법(2) - bind 메서드 활용
bind 메서드를 사용하면 콜백 함수 내부의 this를 명확히 고정할 수 있음. 
this를 명시적으로 바인딩하면 다양한 객체에 재활용할 수 있고, 실행 환경에 상관없이 원하는 this를 유지 가능함.

## 4-12 콜백 지옥 예시(1-1)
콜백을 중첩으로 계속 사용하는 경우 가독성이 매우 떨어지고 유지보수가 어려워짐. 
콜백 지옥(callback hell)이라 부르며, 들여쓰기와 중첩 함수 구조가 복잡함.

## 4-13 콜백 지옥 해결 - 기명함수로 변환
콜백 지옥을 해결하기 위한 첫 번째 방법으로, 익명 함수 대신 기명 함수 사용. 
각 콜백을 분리된 이름 있는 함수로 바꾸면 중첩이 줄고, 가독성과 재사용성이 개선됨.

## 4-14 비동기 작업의 동기적 표현(1) - Promise(1)
Promise를 사용하면 then 체인을 통해 비동기 흐름을 순차적으로 표현할 수 있음. 
콜백 중첩을 피할 수 있고, 가독성이 좋아짐. 콜백보다 더 깔끔한 코드 작성 가능.

## 4-15 비동기 작업의 동기적 표현(2) - Promise(2)
then 체인을 함수화해서 반복 구조를 간결하게 만든 예제. 
각 단계마다 함수 호출로 구성되어 중복을 줄이고 코드가 깔끔해짐. 
재사용성과 구성 유연성 높아짐.

## 4-16 비동기 작업의 동기적 표현(3) - Generator
Generator는 yield 키워드를 통해 실행을 일시 중단하고, 외부에서 next를 호출해 순차 실행 가능함. 
복잡한 비동기 로직을 동기적인 흐름처럼 작성할 수 있게 해줌.

## 4-17 비동기 작업의 동기적 표현(4) - Promise + Async/await
async/await 문법은 가장 간단하고 가독성 높은 비동기 처리 방식. 
async 함수 내부에서 await을 사용해 Promise가 처리될 때까지 기다리고, 코드가 순차적으로 실행되는 것처럼 보이게 함.
